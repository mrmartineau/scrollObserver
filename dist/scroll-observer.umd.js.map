{"version":3,"file":"scroll-observer.umd.js","sources":["../node_modules/just-throttle/index.js","../index.js"],"sourcesContent":["module.exports = throttle;\n\nfunction throttle (fn, interval, immediate) {\n  var wait = false;\n  var callNow = false;\n  return function () {\n    var callNow = immediate && !wait;\n    var context = this;\n    var args = arguments;\n    if (!wait) {\n      wait = true;\n      setTimeout(function () {\n        wait = false;\n        return fn.apply(context, args);\n      }, interval);\n    }\n    if (callNow) {\n      return fn.apply(this, arguments);\n    }\n  }\n}\n","/**\n * ScrollObserver\n * @description Add a class to an element when a specific scroll threshold has been reached\n *\n * @module\n * @author Zander Martineau\n */\nimport throttle from 'just-throttle';\nexport default class {\n  /**\n   * @constructor\n   * @param {Element} element\n   * @param {Object} opts\n   */\n  constructor(element, opts) {\n    this.element = element;\n    const defaultOpts = {\n      threshold: 1,\n      classNameActive: 'scrollObserver-active',\n      classNameInactive: 'scrollObserver-inactive',\n      throttle: 100,\n    };\n    this.opts = Object.assign({}, defaultOpts, opts);\n\n    this.addEvents();\n  }\n\n  addEvents() {\n    window.addEventListener(\n      'scroll',\n      throttle(this.onScroll.bind(this), this.opts.throttle)\n    );\n\n    const threshold = this.opts.threshold;\n    if (threshold === 'this') {\n      this.threshold = getOffset(this.element);\n    } else {\n      if (typeof parseInt(threshold, 10) !== 'number') {\n        throw new Error(\n          '`threshold` value should either be an integer or \"this\"'\n        );\n      }\n      this.threshold = parseInt(threshold, 10);\n    }\n  }\n\n  onScroll(e) {\n    const scrollYPos = window.pageYOffset || document.body.scrollTop;\n\n    if (scrollYPos >= this.threshold) {\n      this.thresholdReached();\n    } else {\n      this.release();\n    }\n  }\n\n  thresholdReached() {\n    this.element.classList.add(this.opts.classNameActive);\n    this.element.classList.remove(this.opts.classNameInactive);\n  }\n\n  release() {\n    this.element.classList.remove(this.opts.classNameActive);\n    this.element.classList.add(this.opts.classNameInactive);\n  }\n}\n\nconst getOffset = elem => {\n  let top = 0;\n\n  while (elem) {\n    top = top + parseInt(elem.offsetTop, 10);\n    elem = elem.offsetParent;\n  }\n\n  return top;\n};\n"],"names":["fn","interval","immediate","wait","callNow","context","this","args","arguments","setTimeout","apply","element","opts","Object","assign","addEvents","addEventListener","throttle","onScroll","bind","threshold","getOffset","parseInt","Error","e","window","pageYOffset","document","body","scrollTop","thresholdReached","release","classList","add","classNameActive","remove","classNameInactive","elem","let","top","offsetTop","offsetParent"],"mappings":"6KAAA,MAEA,SAAmBA,EAAIC,EAAUC,GAC/B,IAAIC,GAAO,EACX,OACO,WACL,IAAIC,EAAUF,IAAcC,EACxBE,EAAUC,KACVC,EAAOC,UAQX,GAPKL,IACHA,GAAO,EACPM,WAAW,WAET,OADAN,GAAO,EACAH,EAAGU,MAAML,EAASE,IACxBN,IAEDG,EACF,OAAOJ,EAAGU,MAAMJ,KAAME,aCT5B,MAME,SAAYG,EAASC,QACdD,QAAUA,OAOVC,KAAOC,OAAOC,qBALN,kBACM,0CACE,mCACT,KAE+BF,QAEtCG,yBAGPA,4BACSC,iBACL,SACAC,EAASX,KAAKY,SAASC,KAAKb,MAAOA,KAAKM,KAAKK,eAGzCG,EAAYd,KAAKM,KAAKQ,aACV,SAAdA,OACGA,UAAYC,EAAUf,KAAKK,aAC3B,IACkC,iBAA5BW,SAASF,EAAW,UACvB,IAAIG,MACR,gEAGCH,UAAYE,SAASF,EAAW,kBAIzCF,kBAASM,IACYC,OAAOC,aAAeC,SAASC,KAAKC,YAErCvB,KAAKc,eAChBU,wBAEAC,uBAITD,iCACOnB,QAAQqB,UAAUC,IAAI3B,KAAKM,KAAKsB,sBAChCvB,QAAQqB,UAAUG,OAAO7B,KAAKM,KAAKwB,gCAG1CL,wBACOpB,QAAQqB,UAAUG,OAAO7B,KAAKM,KAAKsB,sBACnCvB,QAAQqB,UAAUC,IAAI3B,KAAKM,KAAKwB,wBAInCf,WAAYgB,GAGhB,IAFAC,IAAIC,EAAM,EAEHF,GACLE,GAAYjB,SAASe,EAAKG,UAAW,IACrCH,EAAOA,EAAKI,aAGd,OAAOF"}